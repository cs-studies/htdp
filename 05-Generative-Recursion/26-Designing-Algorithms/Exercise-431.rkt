;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname Exercise-431) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
;;
;; Exercise 431.
;; Answer the four key questions for the bundle problem
;; and the first three questions for the quick-sort< problem.
;; How many instances of generate-problem are needed?


;; [List-of 1String] N -> [List-of String]
;; Bundles chunks of s into strings of length n.
(check-expect (bundle '() 2) '())
(check-expect (bundle '("a" "b" "c") 0) '())
(check-expect (bundle '("a" "b") 1) '("a" "b"))
(check-expect (bundle '("a" "b") 2) '("ab"))
(check-expect (bundle '("a" "b") 3) '("ab"))
(check-expect (bundle (explode "abcdefg") 3) '("abc" "def" "g"))
(define (bundle s n)
  (cond
    [(or (zero? n) (empty? s)) '()]
    [else
     (local ((define (take l n)
               (cond
                 [(or (zero? n) (empty? l)) '()]
                 [else (cons (first l) (take (rest l) (sub1 n)))]))

             (define (drop l n)
               (cond
                 [(or (zero? n) (empty? l)) l]
                 [else (drop (rest l) (sub1 n))])))
       (cons (implode (take s n)) (bundle (drop s n) n)))]))

;;; What is a trivially solvable problem?
;;
;; The problem of bundling an empty list
;; or bundling to chunks of the size 0.

;;; How are trivial solutions solved?
;;
;; The trivial solutions produce an empty list.

;;; How does the algorithm generate new problems
;;; that are more easily solvable than the original one?
;;; Is there one new problem that we generate or are there several?
;;
;; The new (one) problem is generated by
;; dropping a chunk of bundled items
;; and continue the bundling process on the remaining items.

;;; Is the solution of the given problem
;;; the same as the solution of (one of) the new problems?
;;; Or, do we need to combine the solutions
;;; to create a solution for the original problem?
;;; And, if so, do we need anything from the original problem data?
;;
;; Yes, the new problem is solved the same way as the original one.
;; The current step problem solution and the new problem solution
;; are combined.


;; [List-of Number] -> [List-of Number]
;; Produces a sorted version of alon.
(check-expect (quick-sort< '()) '())
(check-expect (quick-sort< '(1)) '(1))
(check-expect (quick-sort< (list 11 5 9 2 4)) (list 2 4 5 9 11))
(check-expect (quick-sort< (list 3 2 1 1 2 3)) (list 1 1 2 2 3 3))
(define (quick-sort< alon)
  (cond
    [(or (empty? alon) (empty? (rest alon))) alon]
    [else (local ((define pivot (first alon)))
            (append (quick-sort< (filter (lambda (x) (< x pivot)) alon))
                    (filter (lambda (x) (= x pivot)) alon)
                    (quick-sort< (filter (lambda (x) (> x pivot)) alon))))]))

;;; What is a trivially solvable problem?
;;
;; The problem of sorting an empty list
;; or sorting a list with one item.

;;; How are trivial solutions solved?
;;
;; The trivial solutions produce
;; the same lists as the given one
;; because such lists are already sorted.

;;; How does the algorithm generate new problems
;;; that are more easily solvable than the original one?
;;; Is there one new problem that we generate or are there several?
;;
;; The new (two) problems are generated by
;; performing sorting separately on values smaller than a pivot
;; and on values larger than a pivot.

;;; Is the solution of the given problem
;;; the same as the solution of (one of) the new problems?
;;; Or, do we need to combine the solutions
;;; to create a solution for the original problem?
;;; And, if so, do we need anything from the original problem data?
;;
;; The solutions are combined
;; to create a solution for the original problem.
;; The process appends sorted smallers, largers and a pivot(s)
;; from the given data.
;; (Pivot is taken from the original problem data
;; only on the first step of the recursion.)

